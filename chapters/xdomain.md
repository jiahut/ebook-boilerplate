# [ECCP][RFC] XDomain的宽表数据结构


<a id="orgece24ce"></a>

## 概述

业务单据在业务流转过程中, 将我们关心的领域 (子域) 领域知识汇聚起来, 结构化存储到XDomain中,

当前我们定义的XDomain是一种树型数据结构, 这种数据结构带来的好处是,

以单据为核心对齐了各条业务应用, 所以能快速的基于单据将各个业务应用的数据流串联起来,

从而向上和向下延伸了单据的链条

-   这里有一个假设是我们当前节点是站在票据协同

而另一面, 这种数据结构的特点在基于数据集上的计算上表现出不灵活, 拿价格计算引擎来讲,

-   某个营销活动的返利价格可看做是在符合条件的销售明细数据上做的一次 (或者多次) 计算, 实际场景中,
    -   返利类型有很多种, 每一种都可能需选择符合自己的销售明细 ( 年返, 季返)
    -   返利的规则筛选条件可能细粒度到具体某一个品牌下的某个系列维度 ( 宝岛某个市场活动只针对防蓝光/蓝科二代的商品参与返利活动)
    -   返利的激励对象可能是某个事业部 (这里的事业部是虚拟机的某个组织)

当前XDomain没有存商品的信息 (如品牌/品类/系列), 也并不会存储具体的组织信息, 而价格技术引擎需要这些信息做计算的时候, 应该在什么边界去聚合这些维度的信息呢?

-   XDomain后续会在订单域中补齐商品的一些字段, 但是不会细粒度到商品明细 (比如什么系列)
-   在宝岛的case中商品只能适用于特定的事业部


<a id="org3a442f3"></a>

## 问题或者痛点是什么

当前价格引擎与市场活动的交互流程,

-   价格计算引擎定义返利场景模型下的数据源的输入/输出
-   市场活动根据价格引擎的输入要求, 组装相对应的数据
    -   年返计算出所有单据明细的价格, 如果细分到具体的事业部进行返利, 还需要具体事业部单独分开进行计算

-   价格计算引擎根据市场活动的输入计算后将结构返给市场活动, 进而生成折扣池入池明细
    -   如使用价格引擎 **基于事业部实销梯度** 定价的策略, 相对应的市场活动获取单据并聚合用户中心的组织信息, 计算出某一个时间段内, 该事业部实际发送的销售总金额
    -   如使用价格引擎 **基于商品采购量** 的返利的策略, 相对应的市场活动需要聚合商品信息后算出该商品的一段时间内的采购总金额

上面的流程在数据流向上看会有哪些问题呢?

-   价格引擎应该不感知具体的业务, 价格引擎不存储和持久化具体的需要被计算的数据集, 但是每一种策略需要的数据集是不一样的,
    -   数据集在数量上存在差异, 年返和季返, 基于商品维度被计算的数据量不一样
        -   这里暂时不展开拉出一年内所有的单据可能引发的性能问题
    -   差异还体现在字段上, 数据集必须包含为了完成某个策略需要要的最少字段, 比如基于商品的某个系列返利, 相对应的需要商品相对应的字段 (品牌/品类/系列)
-   多条市场活动叠加时候, 每个数据集的字段不一样, 但是参与计算的数据源是一样的, 每一条策略都重新完整的再组装转化一次数据
    -   某一条具体的明细, 可能同时符合年返, 季返, 基于商品的返利等策略

-   实际项目中,还存在更复杂的场景
    -   宝岛中存在一种品牌反选的场景, 即只要销售明细不满足某个条件即可参与返利策略的计算

最后你会发现, 为了应用某个价格引擎的策略, 需要不断的在不同维度聚合数据集, 而这些最底层可能都是相同的数据进行多次的转换.

-   更可怕的是这种转换的逻辑到底放在XDomian, 还是市场活动?
    -   因为这地方的痛点比较多, 以及后续可预见的遭遇性能问题, 大概率XDomain会压缩传输的数据量


<a id="org6046762"></a>

## 解决方案

所以, 为了能更好的驱动业务, XDomain需要有另一种形式的数据结构, 从源头上解决问题

我们需要一张大的数据表, 一行的信息不仅仅表示的是一次商品的实际销售, 还聚合了商品的明细, 组织架构信息, 为了描述后续我们称之为 **宽表**

-   这个宽表的设计能不能标准化
    -   当前宽表上游的需求是解决价格计算引擎的问题, 如果策略能确定, 宽表的字段也能确定,
    -   但是, 宽表可能不仅仅是为了解决这一个问题, 理论上所有引擎都是在数据集上的操作, 缺乏输入, 不能做太强的假设, 需要后续再分析
-   这个宽表的最细粒度是啥?
    -   这个依据单据的最小粒度, 产值单和出库单的粒度是有差异的.
-   这个宽表聚合了那些信息?
    -   理论上围绕单据明细的所有信息都可以聚合, 可能会有重复数据

这样价格引擎的各种策略需要的输入, 最终落实到在计算层面就是在这个宽表上选定的一批数据集合 (where) , 指定一些字段 (select), 明细上做的一次计算 (包括聚合) ,

-   实际场景中, 价格引擎可能需要在上层组合多次的计算结果来完成具体的策略

这样带来的好处,

-   我们在某个细粒度上将XDomain的结构化数据扁平化后, 所有的数据在这个较低的维度一次性对齐了
    -   注意这里的扁平的含义,
        -   一次采购了3种商品, 在XDomain中可能是商品域的一个对象, 扁平后可能是发生了3次销售明细
        -   具体需不要需要, 依赖于返利场景是否精确到商品, 以及对方的业务单的粒度
    -   对齐是非常重要的, 这样节省了不同的应用之间来回 transform

-   价格引擎只需要依赖于这一份宽表, 更具体的应该是依赖宽表的几个字段,某个返利策略依赖于最小的几个字段就行了
    -   这样, 只需要保证这个宽表相对应是字段有值, 就可以驱动相这个策略跑起来

-   假设有实时性预测等场景的应用, 我们可以做到只要单据落入XDomain, 就生成宽表的数据, 从而驱动应用的计算
    -   根据需要宽表可以连接更多维度的信息来增加更多的字段

-   可复现性, 用户对价格计算的结果有疑问, 需要重新计算时发现单据可能已经变更了, 数据无法对齐, 而宽表会保留最原始的数据
    -   价格计算引擎可以做到幂等, 计算规则和参与计算的数据都可以保存起来

-   更大的好处是, 宽表的设计本质上就是在使用大数据的计算, 市面上有使用成熟的大数据处理的计算, 比如spark


<a id="orgf1a84b8"></a>

### 宽表的更细节的问题

-   宽表数据从什么是进来
    -   这个可能依赖于具体的场景, 假设最小粒度只有季返, 那其实可以一次性生成, 当然我们没办法做这个假设
    -   更好的点应该发生在XDomian相对应的子域落库后, 聚合信息插入到宽表中, 插入一行数据到宽表中

-   理论上宽表是不应该删除掉的, 如果相对应的宽表数据发生变更, 应该产生一条新的数据
    -   大数据计算的时候重复的数据, 可以取到时间戳最新的那一条数据

-   宽表到底应该包含多少个字段, 能不能提前确定下来
    -   一种可能的做法是每种策略定义出自己需要的字段, 这些字段进行一共并集

